import * as path from "std/path/mod.ts";
import { Registry } from "../registry/mod.ts";

export async function generateEntrypoint(registry: Registry) {
	// Generate module configs
	let modImports = "";
	let modConfig = "{";
	for (const mod of registry.modules.values()) {
		modConfig += `${JSON.stringify(mod.name)}: {`;

		// Generate script configs
		modConfig += "scripts: {";
		for (const script of mod.scripts.values()) {
			const handlerIdent = `modules__${mod.name}__${script.name}__handler`;

			modImports +=
				`import { handler as ${handlerIdent} } from '../modules/${mod.name}/scripts/${script.name}.ts';\n`;
			modConfig += `${
				JSON.stringify(script.name)
			}: { handler: ${handlerIdent}, requestSchema: ${
				JSON.stringify(script.requestSchema)
			}, responseSchema: ${JSON.stringify(script.responseSchema)} },`;
		}
		modConfig += "},";

		modConfig += "},";
	}
	modConfig += "}";

	// Generate config.ts
	const configSource = `
// This file is generated by @ogs/engine-builder

import { Config } from "@ogs/runtime";

${modImports}

export default {
    modules: ${modConfig},
} as Config;

`;

	// Generate entrypoint.ts
	const entrypointSource = `
// This file is generated by @ogs/engine-builder

import { Runtime } from "@ogs/runtime";
import config from "./runtime_config.ts";

async function main() {
    const runtime = new Runtime(config);
    await runtime.serve();
}

main();

`;

	// Write file
	const distDir = path.join(registry.path, "dist");
	const configPath = path.join(distDir, "runtime_config.ts");
	const entrypointPath = path.join(distDir, "entrypoint.ts");
	console.log("Writing entrypoint");
	await Deno.mkdir(distDir, { recursive: true });
	await Deno.writeTextFile(configPath, configSource);
	await Deno.writeTextFile(entrypointPath, entrypointSource);

	// Format files
	const { success } = await new Deno.Command("deno", {
		args: ["fmt", configPath, entrypointPath],
	}).output();
	if (!success) throw new Error(`Failed to format generated files`);
}
