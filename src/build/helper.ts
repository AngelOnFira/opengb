import {
	Module,
	moduleDistHelperPath,
	Project,
	Script,
	scriptDistHelperPath,
	testDistHelperPath,
} from "../project/mod.ts";
import * as path from "std/path/mod.ts";

export async function compileScriptHelpers(project: Project) {
	for (const module of project.modules.values()) {
		await compileModuleHelper(project, module);
		await compileTestHelper(project, module);

		for (const script of module.scripts.values()) {
			await compileScriptHelper(project, module, script);
		}
	}

	await compileTypeHelpers(project);
}

async function compileModuleHelper(
	project: Project,
	module: Module,
) {
	console.log("Generating module", module.path);

	// Generate source
	const source = `
import { ModuleContext as ModuleContextInner } from "@ogs/runtime";
${
		module.db
			? `
import prisma from "../../prisma/${module.name}/esm.js";
export { prisma };
export const Prisma = prisma.Prisma;
`
			: ""
	}

export { RuntimeError } from "@ogs/runtime";

export type ModuleContext = ModuleContextInner<${
		module.db ? "prisma.PrismaClient" : "undefined"
	}>;
`;

	// Write source
	const helperPath = moduleDistHelperPath(project, module);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileTestHelper(
	project: Project,
	module: Module,
) {
	console.log("Generating test", module.path);

	// Generate source
	const source = `
import * as module from "./mod.ts";
import { Runtime, TestContext as TestContextInner } from "@ogs/runtime";
import config from "../../../dist/runtime_config.ts";

export * from "./mod.ts";

export type TestContext = TestContextInner<${
		module.db ? "module.prisma.PrismaClient" : "undefined"
	}>;

export type TestFn = (ctx: TestContext) => Promise<void>;

export function test(name: string, fn: TestFn) {
	Runtime.test(config, "${module.name}", name, fn);
}
`;

	// Write source
	const helperPath = testDistHelperPath(project, module);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileScriptHelper(
	project: Project,
	module: Module,
	script: Script,
) {
	console.log("Generating script", script.path);

	// Generate source
	const source = `
import * as module from "../mod.ts";
import { ScriptContext as ScriptContextInner } from "@ogs/runtime";
${
		module.db
			? `import { PrismaClient } from "../../../prisma/${module.name}/index.d.ts";`
			: ""
	}

export * from "../mod.ts";

export type ScriptContext = ScriptContextInner<${
		module.db ? "module.prisma.PrismaClient" : "undefined"
	}>;
`;

	// Write source
	const helperPath = scriptDistHelperPath(project, module, script);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileTypeHelpers(project: Project) {
	const typedefPath = path.join(
		project.path,
		"dist",
		"helpers",
		"registry.d.ts",
	);

	const modules: string[] = [];

	for (const module of project.modules.values()) {
		const scripts: string[] = [];

		const moduleInterfaceName = `${module.name}Module`;
		for (const script of module.scripts.values()) {
			const scriptId = `${module.name}$$${script.name}`;

			const requestTypeName = `${scriptId}Req`;
			const responseTypeName = `${scriptId}Res`;

			const absoluteImportPath = path.join(
				project.path,
				"modules",
				module.name,
				"scripts",
				`${script.name}.ts`,
			);
			const importPath = path.relative(
				path.dirname(typedefPath),
				absoluteImportPath,
			);

			const pathComment = `// ${module.name}/${script.name}`;
			const importLine =
				`import type { Request as ${requestTypeName}, Response as ${responseTypeName} } from ${
					JSON.stringify(importPath)
				};`;

			const interfaceDef = [
				`interface ${moduleInterfaceName} {`,
				`\t${script.name}: {`,
				`\t\trequest: ${requestTypeName};`,
				`\t\tresponse: ${responseTypeName};`,
				`\t};`,
				`}`,
			].join("\n");

			scripts.push([pathComment, importLine, interfaceDef].join("\n"));
		}

		const moduleComment = `//\n// Types for ${module.name}\n//`;
		const scriptBody = scripts.join("\n\n");

		const interfaceDef =
			`interface Registry {\n\t${module.name}: ${moduleInterfaceName};\n}`;

		modules.push([moduleComment, scriptBody, interfaceDef].join("\n"));
	}

	const source = `${autoGeneratedHeader.trim()}}\n\n${
		modules.join("\n\n\n\n")
	}\n\n${registryTypes.trim()}`;
	await Deno.mkdir(path.dirname(typedefPath), { recursive: true });
	await Deno.writeTextFile(typedefPath, source);
}

const autoGeneratedHeader = `
// This file is auto-generated by the OGS build system.
// Do not edit this file directly.
`;

const registryTypes = `
export type RequestOf<T> = T extends { request: any } ? T["request"] : never;
export type ResponseOf<T> = T extends { response: any } ? T["response"] : never;

export type RegistryCallFn<ThisType> = <M extends keyof Registry & string, S extends keyof Registry[M] & string>(
	this: ThisType,
	module: M,
	script: S,
	req: RequestOf<Registry[M][S]>,
) => Promise<ResponseOf<Registry[M][S]>>;`;
