import { copy, resolve } from "../deps.ts";
import { dedent, PostgresClient } from "./deps.ts";
import { Module, ModuleDatabase, Project } from "../project/mod.ts";
import { assertValidString } from "./validate.ts";
import { emptyDir } from "../deps.ts";
import { CommandError } from "../error/mod.ts";
import { addShutdownHandler } from "../utils/shutdown_handler.ts";

const NODE_IMAGE = "node:21-alpine";
const NODE_CONTAINER_NAME = "opengb-node";
const PRISMA_VERSION = "5.9.1";

export type ForEachDatabaseCallback = (
	opts: { databaseUrl: string; module: Module; db: ModuleDatabase },
) => Promise<void>;
export type ForEachPrismaSchemaCallback = (
	opts: {
		databaseUrl: string;
		module: Module;
		db: ModuleDatabase;
		tempDir: string;
		generatedClientDir: string;
	},
) => Promise<void>;

interface DbState {
	defaultClient: PostgresClient | null;
	createdDatabases: Set<string>;
}

/**
 * State about the databases for the current process.
 */
const DB_STATE: DbState = {
	defaultClient: null,
	createdDatabases: new Set(),
};

/** Prepares all databases and calls a callback once prepared. */
export async function forEachDatabase(
	_project: Project,
	modules: Module[],
	callback: ForEachDatabaseCallback,
) {
	// Setup database
	const defaultDatabaseUrl = Deno.env.get("DATABASE_URL") ??
		"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable";

	// Create client that connects to the default database
	if (!DB_STATE.defaultClient) {
		DB_STATE.defaultClient = new PostgresClient(defaultDatabaseUrl);
		await DB_STATE.defaultClient.connect();

		addShutdownHandler(async () => {
			await DB_STATE.defaultClient?.end();
		});
	}

	for (const mod of modules) {
		if (!mod.db) continue;

		// Create database
		await createDatabases(DB_STATE.defaultClient, mod.db);

		// Build URL
		const urlParsed = new URL(defaultDatabaseUrl);
		urlParsed.pathname = `/${mod.db.name}`;
		const databaseUrl = urlParsed.toString();

		// Callback
		await callback({ databaseUrl, module: mod, db: mod.db });
	}
}

/** Prepares the Postgres database & creates a temporary Prisma project for each database. */
export async function forEachPrismaSchema(
	project: Project,
	modules: Module[],
	callback: ForEachPrismaSchemaCallback,
) {
	await forEachDatabase(
		project,
		modules,
		async ({ databaseUrl, module, db }) => {
			const prismaDir = await ensurePrismaWorkspace(project);

			const srcDbDir = resolve(module.path, "db");
			const dstDbDir = resolve(prismaDir, "db");

			const generatedClientDir = resolve(
				prismaDir,
				"client",
			);

			// Copy db directory
			await emptyDir(dstDbDir);
			await copy(srcDbDir, dstDbDir, { overwrite: true });

			// Append generator config
			const schemaPath = resolve(dstDbDir, "schema.prisma");
			let schema = await Deno.readTextFile(schemaPath);
			schema += dedent`

				// Generated by Open Game Backend
				generator client {
					provider = "prisma-client-js"
					output = "/prisma/client"
					previewFeatures = ["driverAdapters"]
				}
			`;
			await Deno.writeTextFile(schemaPath, schema);

			// Callback
			await callback({ databaseUrl, module, db, tempDir: prismaDir, generatedClientDir });
		},
	);
}

/**
 * Create databases for a module.
 */
async function createDatabases(client: PostgresClient, db: ModuleDatabase) {
	// Check if already created
	if (DB_STATE.createdDatabases.has(db.name)) return;

	// Create database
	const existsQuery = await client.queryObject<
		{ exists: boolean }
	>`SELECT EXISTS (SELECT FROM pg_database WHERE datname = ${db.name})`;
	if (!existsQuery.rows[0].exists) {
		await client.queryObject(`CREATE DATABASE ${assertValidString(db.name)}`);
	}

	// Save as created
	DB_STATE.createdDatabases.add(db.name);
}

/**
 * Context about the Prisma workspace for the current process.
 */
const PRISMA_WORKSPACE_STATE = {
	didRunInstall: false,
	didStartContainer: false,
};

/**
 * Installs a copy of Prisma in to a directory that can be reused for any
 * Prisma-related commands.
 *
 * All commands are ran inside a Node Docker container in order to ensure we
 * don't need Node installed on the host.
 */
async function ensurePrismaWorkspace(project: Project): Promise<string> {
	const prismaDir = resolve(project.path, "_gen", "prisma_workspace");
	await Deno.mkdir(prismaDir, { recursive: true });

	// Start Node container to run Prisma commands
	if (!PRISMA_WORKSPACE_STATE.didStartContainer) {
		// Remove the existing container if exists. This forces the new
		// configuration for a new container.
		const rmOutput = await new Deno.Command("docker", {
			args: ["rm", "-f", NODE_CONTAINER_NAME],
		}).output();
		if (!rmOutput.success) {
			throw new CommandError("Failed to remove the existing container.", { commandOutput: rmOutput });
		}

		// Start the container
		const runOutput = await new Deno.Command("docker", {
			args: [
				"run",
				"-d",
				"--rm",
				`--name=${NODE_CONTAINER_NAME}`,
				"--add-host=host.docker.internal:host-gateway",
				`--volume=${prismaDir}:/prisma`,
				"--entrypoint=sleep",
				NODE_IMAGE,
				// ===
				"infinity",
			],
		}).output();
		if (!runOutput.success) {
			throw new CommandError("Failed to start the container.", { commandOutput: runOutput });
		}

		addShutdownHandler(shutdownNodeContainer);

		PRISMA_WORKSPACE_STATE.didStartContainer = true;
	}

	// Install Prisma
	if (!PRISMA_WORKSPACE_STATE.didRunInstall) {
		PRISMA_WORKSPACE_STATE.didRunInstall = true;

		// Write package.json
		const packageJson = JSON.stringify({
			"devDependencies": {
				"prisma": `^${PRISMA_VERSION}`,
			},
			"dependencies": {
				"@prisma/client": `^${PRISMA_VERSION}`,
			},
		});
		await Deno.writeTextFile(resolve(prismaDir, "package.json"), packageJson);

		// Fix permissions on the repo
		const chownOutput = await new Deno.Command("docker", {
			args: [
				"exec",
				NODE_CONTAINER_NAME,
				// ===
				"chown",
				"-R",
				"node:node",
				"/prisma",
			],
			stdout: "inherit",
			stderr: "inherit",
		}).output();
		if (!chownOutput.success) throw new CommandError("Failed to fix permissions.", { commandOutput: chownOutput });

		// Install dependencies
		const installOutput = await new Deno.Command("docker", {
			args: [
				"exec",
				"--workdir=/prisma",
				`--user=node:node`,
				NODE_CONTAINER_NAME,
				// ===
				"npm",
				"install",
				"--prefer-offline",
				"--no-audit",
				"--no-fund",
				"--progress=false",
			],
			stdout: "inherit",
			stderr: "inherit",
		}).output();
		if (!installOutput.success) {
			throw new CommandError("Failed to install prisma dependencies.", { commandOutput: installOutput });
		}

		// Fix permissions on the repo
		const chownOutput2 = await new Deno.Command("docker", {
			args: [
				"exec",
				NODE_CONTAINER_NAME,
				// ===
				"chown",
				"-R",
				`${Deno.uid()}:${Deno.gid()}`,
				"/prisma",
			],
			stdout: "inherit",
			stderr: "inherit",
		}).output();
		if (!chownOutput2.success) throw new CommandError("Failed to fix permissions.", { commandOutput: chownOutput2 });
	}

	return prismaDir;
}

/**
 * Shutdown the Node helper container.
 *
 * This is sync so it can run in `unload`.
 */
async function shutdownNodeContainer() {
	const shutdownOutput = await new Deno.Command("docker", {
		args: ["rm", "-f", NODE_CONTAINER_NAME],
	}).output();
	if (!shutdownOutput.success) {
		throw new CommandError("Failed to stop the container.", { commandOutput: shutdownOutput });
	}
}

export interface RunPrismaCommandOpts {
	args: string[];
	env: Record<string, string>;
}

/**
 * Run a Prisma command in the Prisma workspace inside the Docker container. The
 * CWD is set to the `db` directory.
 *
 * We don't use `deno run npm:prisma` because:
 *
 * - We already have Prisma installed in the workspace
 * - There are minor bugs with Deno's compatability with Prisma
 */
export async function runPrismaCommand(
	project: Project,
	opts: RunPrismaCommandOpts & Deno.CommandOptions,
) {
	await ensurePrismaWorkspace(project);

	// HACK: Replace the host with the Docker gateway. This isn't a failsave solution.
	if (opts.env.DATABASE_URL) {
		opts.env.DATABASE_URL = opts.env.DATABASE_URL
			.replace("localhost", "host.docker.internal")
			.replace("127.0.0.1", "host.docker.internal")
			.replace("0.0.0.0", "host.docker.internal");
	}

	const envFlags = Object.entries(opts.env).map(([key, value]) => `--env=${key}=${value}`);

	// Fix permissions on the repo
	const chownOutput = await new Deno.Command("docker", {
		args: [
			"exec",
			NODE_CONTAINER_NAME,
			// ===
			"chown",
			"-R",
			"node:node",
			"/prisma",
		],
		stdout: "inherit",
		stderr: "inherit",
	}).output();
	if (!chownOutput.success) throw new CommandError("Failed to fix permissions.", { commandOutput: chownOutput });

	// Run the command
	// TODO: This won't work in CI without TTY
	const prismaOutput = await new Deno.Command("docker", {
		args: [
			"exec",
			...(Deno.stdin.isTerminal() ? ["-it"] : []),
			"--workdir=/prisma/db",
			`--user=node:node`,
			...envFlags,
			NODE_CONTAINER_NAME,
			"npx",
			"prisma",
			...opts.args,
		],
		stdin: "inherit",
		stdout: "inherit",
		stderr: "inherit",
		env: opts.env,
	}).output();
	if (!prismaOutput.success) {
		throw new CommandError(`Failed to run: prisma ${opts.args.join(" ")}`, { commandOutput: prismaOutput });
	}

	// Fix permissions on the repo
	const chownOutput2 = await new Deno.Command("docker", {
		args: [
			"exec",
			NODE_CONTAINER_NAME,
			// ===
			"chown",
			"-R",
			`${Deno.uid()}:${Deno.gid()}`,
			"/prisma",
		],
		stdout: "inherit",
		stderr: "inherit",
	}).output();
	if (!chownOutput2.success) throw new CommandError("Failed to fix permissions.", { commandOutput: chownOutput2 });
}
